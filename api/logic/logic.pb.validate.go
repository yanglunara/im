// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/logic/logic.proto

package logic

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PushMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PushMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PushMessageMultiError, or
// nil if none found.
func (m *PushMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *PushMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Operation

	// no validation rules for Speed

	// no validation rules for Servrice

	// no validation rules for Room

	// no validation rules for Msg

	if len(errors) > 0 {
		return PushMessageMultiError(errors)
	}

	return nil
}

// PushMessageMultiError is an error wrapping multiple validation errors
// returned by PushMessage.ValidateAll() if the designated constraints aren't met.
type PushMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushMessageMultiError) AllErrors() []error { return m }

// PushMessageValidationError is the validation error returned by
// PushMessage.Validate if the designated constraints aren't met.
type PushMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushMessageValidationError) ErrorName() string { return "PushMessageValidationError" }

// Error satisfies the builtin error interface
func (e PushMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushMessageValidationError{}

// Validate checks the field values on ConnectReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectReqMultiError, or
// nil if none found.
func (m *ConnectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Server

	// no validation rules for Cookie

	// no validation rules for Token

	if len(errors) > 0 {
		return ConnectReqMultiError(errors)
	}

	return nil
}

// ConnectReqMultiError is an error wrapping multiple validation errors
// returned by ConnectReq.ValidateAll() if the designated constraints aren't met.
type ConnectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectReqMultiError) AllErrors() []error { return m }

// ConnectReqValidationError is the validation error returned by
// ConnectReq.Validate if the designated constraints aren't met.
type ConnectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectReqValidationError) ErrorName() string { return "ConnectReqValidationError" }

// Error satisfies the builtin error interface
func (e ConnectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectReqValidationError{}

// Validate checks the field values on ConnectResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectRespMultiError, or
// nil if none found.
func (m *ConnectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mid

	// no validation rules for Key

	// no validation rules for RoomID

	// no validation rules for Heartbeat

	if len(errors) > 0 {
		return ConnectRespMultiError(errors)
	}

	return nil
}

// ConnectRespMultiError is an error wrapping multiple validation errors
// returned by ConnectResp.ValidateAll() if the designated constraints aren't met.
type ConnectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectRespMultiError) AllErrors() []error { return m }

// ConnectRespValidationError is the validation error returned by
// ConnectResp.Validate if the designated constraints aren't met.
type ConnectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectRespValidationError) ErrorName() string { return "ConnectRespValidationError" }

// Error satisfies the builtin error interface
func (e ConnectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectRespValidationError{}

// Validate checks the field values on DisconnectReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisconnectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisconnectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisconnectReqMultiError, or
// nil if none found.
func (m *DisconnectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DisconnectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mid

	if utf8.RuneCountInString(m.GetKey()) < 1 {
		err := DisconnectReqValidationError{
			field:  "Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServer()) < 1 {
		err := DisconnectReqValidationError{
			field:  "Server",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DisconnectReqMultiError(errors)
	}

	return nil
}

// DisconnectReqMultiError is an error wrapping multiple validation errors
// returned by DisconnectReq.ValidateAll() if the designated constraints
// aren't met.
type DisconnectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisconnectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisconnectReqMultiError) AllErrors() []error { return m }

// DisconnectReqValidationError is the validation error returned by
// DisconnectReq.Validate if the designated constraints aren't met.
type DisconnectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisconnectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisconnectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisconnectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisconnectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisconnectReqValidationError) ErrorName() string { return "DisconnectReqValidationError" }

// Error satisfies the builtin error interface
func (e DisconnectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisconnectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisconnectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisconnectReqValidationError{}

// Validate checks the field values on DisconnectResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisconnectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisconnectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisconnectRespMultiError,
// or nil if none found.
func (m *DisconnectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DisconnectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Has

	if len(errors) > 0 {
		return DisconnectRespMultiError(errors)
	}

	return nil
}

// DisconnectRespMultiError is an error wrapping multiple validation errors
// returned by DisconnectResp.ValidateAll() if the designated constraints
// aren't met.
type DisconnectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisconnectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisconnectRespMultiError) AllErrors() []error { return m }

// DisconnectRespValidationError is the validation error returned by
// DisconnectResp.Validate if the designated constraints aren't met.
type DisconnectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisconnectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisconnectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisconnectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisconnectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisconnectRespValidationError) ErrorName() string { return "DisconnectRespValidationError" }

// Error satisfies the builtin error interface
func (e DisconnectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisconnectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisconnectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisconnectRespValidationError{}

// Validate checks the field values on HeartbeatReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeartbeatReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartbeatReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeartbeatReqMultiError, or
// nil if none found.
func (m *HeartbeatReq) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartbeatReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mid

	if utf8.RuneCountInString(m.GetKey()) < 1 {
		err := HeartbeatReqValidationError{
			field:  "Key",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServer()) < 1 {
		err := HeartbeatReqValidationError{
			field:  "Server",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return HeartbeatReqMultiError(errors)
	}

	return nil
}

// HeartbeatReqMultiError is an error wrapping multiple validation errors
// returned by HeartbeatReq.ValidateAll() if the designated constraints aren't met.
type HeartbeatReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartbeatReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartbeatReqMultiError) AllErrors() []error { return m }

// HeartbeatReqValidationError is the validation error returned by
// HeartbeatReq.Validate if the designated constraints aren't met.
type HeartbeatReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartbeatReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartbeatReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartbeatReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartbeatReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartbeatReqValidationError) ErrorName() string { return "HeartbeatReqValidationError" }

// Error satisfies the builtin error interface
func (e HeartbeatReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartbeatReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartbeatReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartbeatReqValidationError{}

// Validate checks the field values on HeartbeatResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeartbeatResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartbeatResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeartbeatRespMultiError, or
// nil if none found.
func (m *HeartbeatResp) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartbeatResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Has

	if len(errors) > 0 {
		return HeartbeatRespMultiError(errors)
	}

	return nil
}

// HeartbeatRespMultiError is an error wrapping multiple validation errors
// returned by HeartbeatResp.ValidateAll() if the designated constraints
// aren't met.
type HeartbeatRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartbeatRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartbeatRespMultiError) AllErrors() []error { return m }

// HeartbeatRespValidationError is the validation error returned by
// HeartbeatResp.Validate if the designated constraints aren't met.
type HeartbeatRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartbeatRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartbeatRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartbeatRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartbeatRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartbeatRespValidationError) ErrorName() string { return "HeartbeatRespValidationError" }

// Error satisfies the builtin error interface
func (e HeartbeatRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartbeatResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartbeatRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartbeatRespValidationError{}

// Validate checks the field values on OnlineReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OnlineReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OnlineReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OnlineReqMultiError, or nil
// if none found.
func (m *OnlineReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OnlineReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetServer()) < 1 {
		err := OnlineReqValidationError{
			field:  "Server",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRoomCount()) < 1 {
		err := OnlineReqValidationError{
			field:  "RoomCount",
			reason: "value must contain at least 1 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OnlineReqMultiError(errors)
	}

	return nil
}

// OnlineReqMultiError is an error wrapping multiple validation errors returned
// by OnlineReq.ValidateAll() if the designated constraints aren't met.
type OnlineReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OnlineReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OnlineReqMultiError) AllErrors() []error { return m }

// OnlineReqValidationError is the validation error returned by
// OnlineReq.Validate if the designated constraints aren't met.
type OnlineReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OnlineReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OnlineReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OnlineReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OnlineReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OnlineReqValidationError) ErrorName() string { return "OnlineReqValidationError" }

// Error satisfies the builtin error interface
func (e OnlineReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOnlineReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OnlineReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OnlineReqValidationError{}

// Validate checks the field values on OnlineResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OnlineResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OnlineResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OnlineRespMultiError, or
// nil if none found.
func (m *OnlineResp) ValidateAll() error {
	return m.validate(true)
}

func (m *OnlineResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AllRoomCount

	if len(errors) > 0 {
		return OnlineRespMultiError(errors)
	}

	return nil
}

// OnlineRespMultiError is an error wrapping multiple validation errors
// returned by OnlineResp.ValidateAll() if the designated constraints aren't met.
type OnlineRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OnlineRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OnlineRespMultiError) AllErrors() []error { return m }

// OnlineRespValidationError is the validation error returned by
// OnlineResp.Validate if the designated constraints aren't met.
type OnlineRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OnlineRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OnlineRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OnlineRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OnlineRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OnlineRespValidationError) ErrorName() string { return "OnlineRespValidationError" }

// Error satisfies the builtin error interface
func (e OnlineRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOnlineResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OnlineRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OnlineRespValidationError{}

// Validate checks the field values on ReceiveReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReceiveReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReceiveReqMultiError, or
// nil if none found.
func (m *ReceiveReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mid

	if all {
		switch v := interface{}(m.GetProto()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiveReqValidationError{
					field:  "Proto",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiveReqValidationError{
					field:  "Proto",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProto()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiveReqValidationError{
				field:  "Proto",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceiveReqMultiError(errors)
	}

	return nil
}

// ReceiveReqMultiError is an error wrapping multiple validation errors
// returned by ReceiveReq.ValidateAll() if the designated constraints aren't met.
type ReceiveReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveReqMultiError) AllErrors() []error { return m }

// ReceiveReqValidationError is the validation error returned by
// ReceiveReq.Validate if the designated constraints aren't met.
type ReceiveReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveReqValidationError) ErrorName() string { return "ReceiveReqValidationError" }

// Error satisfies the builtin error interface
func (e ReceiveReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveReqValidationError{}

// Validate checks the field values on ReceiveResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReceiveResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiveResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReceiveRespMultiError, or
// nil if none found.
func (m *ReceiveResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiveResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReceiveRespMultiError(errors)
	}

	return nil
}

// ReceiveRespMultiError is an error wrapping multiple validation errors
// returned by ReceiveResp.ValidateAll() if the designated constraints aren't met.
type ReceiveRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiveRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiveRespMultiError) AllErrors() []error { return m }

// ReceiveRespValidationError is the validation error returned by
// ReceiveResp.Validate if the designated constraints aren't met.
type ReceiveRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiveRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiveRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiveRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiveRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiveRespValidationError) ErrorName() string { return "ReceiveRespValidationError" }

// Error satisfies the builtin error interface
func (e ReceiveRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiveResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiveRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiveRespValidationError{}

// Validate checks the field values on NodesReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodesReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodesReqMultiError, or nil
// if none found.
func (m *NodesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *NodesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPlatform()) < 1 {
		err := NodesReqValidationError{
			field:  "Platform",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClientIP()) < 1 {
		err := NodesReqValidationError{
			field:  "ClientIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NodesReqMultiError(errors)
	}

	return nil
}

// NodesReqMultiError is an error wrapping multiple validation errors returned
// by NodesReq.ValidateAll() if the designated constraints aren't met.
type NodesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodesReqMultiError) AllErrors() []error { return m }

// NodesReqValidationError is the validation error returned by
// NodesReq.Validate if the designated constraints aren't met.
type NodesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodesReqValidationError) ErrorName() string { return "NodesReqValidationError" }

// Error satisfies the builtin error interface
func (e NodesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodesReqValidationError{}

// Validate checks the field values on NodesResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodesResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodesRespMultiError, or nil
// if none found.
func (m *NodesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *NodesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDomain()) < 1 {
		err := NodesRespValidationError{
			field:  "Domain",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetTcpPort(); val < 1024 || val > 65535 {
		err := NodesRespValidationError{
			field:  "TcpPort",
			reason: "value must be inside range [1024, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetWsPort(); val < 1024 || val > 65535 {
		err := NodesRespValidationError{
			field:  "WsPort",
			reason: "value must be inside range [1024, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetWssPort(); val < 1024 || val > 65535 {
		err := NodesRespValidationError{
			field:  "WssPort",
			reason: "value must be inside range [1024, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetHeartbeat() < 1 {
		err := NodesRespValidationError{
			field:  "Heartbeat",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNodes()) < 1 {
		err := NodesRespValidationError{
			field:  "Nodes",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBackoff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodesRespValidationError{
					field:  "Backoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodesRespValidationError{
					field:  "Backoff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBackoff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodesRespValidationError{
				field:  "Backoff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HeartbeatMax

	if len(errors) > 0 {
		return NodesRespMultiError(errors)
	}

	return nil
}

// NodesRespMultiError is an error wrapping multiple validation errors returned
// by NodesResp.ValidateAll() if the designated constraints aren't met.
type NodesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodesRespMultiError) AllErrors() []error { return m }

// NodesRespValidationError is the validation error returned by
// NodesResp.Validate if the designated constraints aren't met.
type NodesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodesRespValidationError) ErrorName() string { return "NodesRespValidationError" }

// Error satisfies the builtin error interface
func (e NodesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodesRespValidationError{}

// Validate checks the field values on Backoff with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Backoff) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Backoff with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BackoffMultiError, or nil if none found.
func (m *Backoff) ValidateAll() error {
	return m.validate(true)
}

func (m *Backoff) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxDelay

	// no validation rules for BaseDelay

	// no validation rules for Factor

	// no validation rules for Jitter

	if len(errors) > 0 {
		return BackoffMultiError(errors)
	}

	return nil
}

// BackoffMultiError is an error wrapping multiple validation errors returned
// by Backoff.ValidateAll() if the designated constraints aren't met.
type BackoffMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackoffMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackoffMultiError) AllErrors() []error { return m }

// BackoffValidationError is the validation error returned by Backoff.Validate
// if the designated constraints aren't met.
type BackoffValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackoffValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackoffValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackoffValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackoffValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackoffValidationError) ErrorName() string { return "BackoffValidationError" }

// Error satisfies the builtin error interface
func (e BackoffValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackoff.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackoffValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackoffValidationError{}
